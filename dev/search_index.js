var documenterSearchIndex = {"docs":
[{"location":"Grids/","page":"Poingr.Grids","title":"Poingr.Grids","text":"CurrentModule = Poingr.Grids","category":"page"},{"location":"Grids/#Poingr.Grids","page":"Poingr.Grids","title":"Poingr.Grids","text":"","category":"section"},{"location":"Grids/","page":"Poingr.Grids","title":"Poingr.Grids","text":"Modules = [Grids]\nOrder = [:type, :function]","category":"page"},{"location":"Grids/","page":"Poingr.Grids","title":"Poingr.Grids","text":"Modules = [Grids]\nOrder = [:type, :function]","category":"page"},{"location":"Grids/#Poingr.Grids.Grid","page":"Poingr.Grids","title":"Poingr.Grids.Grid","text":"Grid(axes::AbstractVector...)\n\nConstruct Grid by axes.\n\nExamples\n\njulia> grid = Grid(range(0, 3, step = 1.0), range(1, 4, step = 1.0))\n4×4 Grid{2, Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}:\n [0.0, 1.0]  [0.0, 2.0]  [0.0, 3.0]  [0.0, 4.0]\n [1.0, 1.0]  [1.0, 2.0]  [1.0, 3.0]  [1.0, 4.0]\n [2.0, 1.0]  [2.0, 2.0]  [2.0, 3.0]  [2.0, 4.0]\n [3.0, 1.0]  [3.0, 2.0]  [3.0, 3.0]  [3.0, 4.0]\n\n\n\n\n\n","category":"type"},{"location":"Grids/#Poingr.Grids.neighboring_cells-Union{Tuple{dim}, Tuple{AbstractGrid{dim, T} where T, CartesianIndex{dim}, Int64}} where dim","page":"Poingr.Grids","title":"Poingr.Grids.neighboring_cells","text":"neighboring_cells(grid, x::Vec, h::Int)\nneighboring_cells(grid, cellindex::CartesianIndex, h::Int)\n\nReturn CartesianIndices storing neighboring cell indices around x. h is number of outer cells around cell where x locates. In 1D, for example, the searching range becomes x ± h*dx.\n\nExamples\n\njulia> grid = Grid(0.0:1.0:5.0, 0.0:1.0:5.0)\n6×6 Grid{2, Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}:\n [0.0, 0.0]  [0.0, 1.0]  [0.0, 2.0]  [0.0, 3.0]  [0.0, 4.0]  [0.0, 5.0]\n [1.0, 0.0]  [1.0, 1.0]  [1.0, 2.0]  [1.0, 3.0]  [1.0, 4.0]  [1.0, 5.0]\n [2.0, 0.0]  [2.0, 1.0]  [2.0, 2.0]  [2.0, 3.0]  [2.0, 4.0]  [2.0, 5.0]\n [3.0, 0.0]  [3.0, 1.0]  [3.0, 2.0]  [3.0, 3.0]  [3.0, 4.0]  [3.0, 5.0]\n [4.0, 0.0]  [4.0, 1.0]  [4.0, 2.0]  [4.0, 3.0]  [4.0, 4.0]  [4.0, 5.0]\n [5.0, 0.0]  [5.0, 1.0]  [5.0, 2.0]  [5.0, 3.0]  [5.0, 4.0]  [5.0, 5.0]\n\njulia> x = Vec(1.5, 1.5);\n\njulia> neighboring_cells(grid, x, 1)\n3×3 CartesianIndices{2, Tuple{UnitRange{Int64}, UnitRange{Int64}}}:\n CartesianIndex(1, 1)  CartesianIndex(1, 2)  CartesianIndex(1, 3)\n CartesianIndex(2, 1)  CartesianIndex(2, 2)  CartesianIndex(2, 3)\n CartesianIndex(3, 1)  CartesianIndex(3, 2)  CartesianIndex(3, 3)\n\njulia> neighboring_cells(grid, whichcell(grid, x), 1) == ans\ntrue\n\n\n\n\n\n","category":"method"},{"location":"Grids/#Poingr.Grids.neighboring_nodes-Union{Tuple{dim}, Tuple{AbstractGrid{dim, T} where T, Vec{dim, T} where T, Real}} where dim","page":"Poingr.Grids","title":"Poingr.Grids.neighboring_nodes","text":"neighboring_nodes(grid, x::Vec, h::Real)\n\nReturn CartesianIndices storing neighboring node indices around x. h is a range for searching and its unit is gridsteps dx. In 1D, for example, the searching range becomes x ± h*dx.\n\nExamples\n\njulia> grid = Grid(0.0:1.0:5.0)\n6-element Grid{1, Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}:\n [0.0]\n [1.0]\n [2.0]\n [3.0]\n [4.0]\n [5.0]\n\njulia> neighboring_nodes(grid, Vec(1.5), 1)\n2-element CartesianIndices{1, Tuple{UnitRange{Int64}}}:\n CartesianIndex(2,)\n CartesianIndex(3,)\n\njulia> neighboring_nodes(grid, Vec(1.5), 2)\n4-element CartesianIndices{1, Tuple{UnitRange{Int64}}}:\n CartesianIndex(1,)\n CartesianIndex(2,)\n CartesianIndex(3,)\n CartesianIndex(4,)\n\n\n\n\n\n","category":"method"},{"location":"Grids/#Poingr.Grids.whichcell-Union{Tuple{dim}, Tuple{AbstractGrid{dim, T} where T, Vec{dim, T} where T}} where dim","page":"Poingr.Grids","title":"Poingr.Grids.whichcell","text":"whichcell(grid, x::Vec)\n\nReturn cell index where x locates.\n\nExamples\n\njulia> grid = Grid(0.0:1.0:5.0, 0.0:1.0:5.0)\n6×6 Grid{2, Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}:\n [0.0, 0.0]  [0.0, 1.0]  [0.0, 2.0]  [0.0, 3.0]  [0.0, 4.0]  [0.0, 5.0]\n [1.0, 0.0]  [1.0, 1.0]  [1.0, 2.0]  [1.0, 3.0]  [1.0, 4.0]  [1.0, 5.0]\n [2.0, 0.0]  [2.0, 1.0]  [2.0, 2.0]  [2.0, 3.0]  [2.0, 4.0]  [2.0, 5.0]\n [3.0, 0.0]  [3.0, 1.0]  [3.0, 2.0]  [3.0, 3.0]  [3.0, 4.0]  [3.0, 5.0]\n [4.0, 0.0]  [4.0, 1.0]  [4.0, 2.0]  [4.0, 3.0]  [4.0, 4.0]  [4.0, 5.0]\n [5.0, 0.0]  [5.0, 1.0]  [5.0, 2.0]  [5.0, 3.0]  [5.0, 4.0]  [5.0, 5.0]\n\njulia> whichcell(grid, Vec(1.5, 1.5))\nCartesianIndex(2, 2)\n\n\n\n\n\n","category":"method"},{"location":"ContactMechanics/","page":"Poingr.ContactMechanics","title":"Poingr.ContactMechanics","text":"CurrentModule = Poingr.ContactMechanics","category":"page"},{"location":"ContactMechanics/#Poingr.ContactMechanics","page":"Poingr.ContactMechanics","title":"Poingr.ContactMechanics","text":"","category":"section"},{"location":"ContactMechanics/","page":"Poingr.ContactMechanics","title":"Poingr.ContactMechanics","text":"Modules = [ContactMechanics]\nOrder = [:type, :function]","category":"page"},{"location":"ContactMechanics/","page":"Poingr.ContactMechanics","title":"Poingr.ContactMechanics","text":"Modules = [ContactMechanics]\nOrder = [:type, :function]","category":"page"},{"location":"ContactMechanics/#Poingr.ContactMechanics.Contact","page":"Poingr.ContactMechanics","title":"Poingr.ContactMechanics.Contact","text":"Contact(:sticky)\nContact(:slip; sep)\nContact(:friction, coef; sep)\n\nContact condition handling contact mechanics in MPM. Following conditions are available:\n\n:sticky: Continuum body is sticked on the boundary surface.\n:slip: Continuum body is slipped on the boundary surface.\n:friction: Continuum body is slipped with frictional coefficient coef on the boundary surface.\n\nIf sep is true, continuum body can leave from the boundary surface.\n\nExamples\n\njulia> Contact(:sticky)\nContact(:sticky)\n\njulia> Contact(:slip, sep = true)\nContact(:slip; sep = true)\n\njulia> Contact(:friction, 0.3, sep = true)\nContact(:friction, 0.3; sep = true)\n\n\n\n(::Contact)(v::Vec, n::Vec)\n\nCompute velocity v caused by contact. The other quantities, which are equivalent to velocity such as momentum and force, are also available. n is the normal unit vector.\n\nExamples\n\njulia> contact = Contact(:slip, sep = false);\n\njulia> v = Vec(1.0, -1.0); n = Vec(0.0, -1.0);\n\njulia> v + contact(v, n)\n2-element Vec{2, Float64}:\n 1.0\n 0.0\n\n\n\n\n\n","category":"type"},{"location":"Loggers/","page":"Poingr.Loggers","title":"Poingr.Loggers","text":"CurrentModule = Poingr.Loggers","category":"page"},{"location":"Loggers/#Poingr.Loggers","page":"Poingr.Loggers","title":"Poingr.Loggers","text":"","category":"section"},{"location":"Loggers/","page":"Poingr.Loggers","title":"Poingr.Loggers","text":"Modules = [Loggers]\nOrder = [:type, :function]","category":"page"},{"location":"Loggers/","page":"Poingr.Loggers","title":"Poingr.Loggers","text":"Modules = [Loggers]\nOrder = [:type, :function]","category":"page"},{"location":"Loggers/#Poingr.Loggers.Logger","page":"Poingr.Loggers","title":"Poingr.Loggers.Logger","text":"Logger(logpoints::AbstractVector; progress = false)\n\nConstruct logger which handle with time event in the calculation. The workflow using Logger can be written as follows:\n\nfunction workflow()\n    logpoints = 0:0.5:5\n    logger = Logger(logpoints)\n    t = 0.0\n    dt = 0.2\n    timestamps = Float64[]\n\n    while !isfinised(logger, t)\n        #\n        # 1. Calculations...\n        #\n\n        # 2. Update time step and logger\n        update!(logger, t += dt)\n\n        #\n        # 3. Save data at log point\n        #\n        if islogpoint(logger)\n\n            # linear index is available for numbering data\n            i = logindex(logger)\n\n            push!(timestamps, t)\n        end\n    end\n\n    timestamps\nend\n\nworkflow()\n\n# output\n\n11-element Vector{Float64}:\n 0.2\n 0.6000000000000001\n 1.0\n 1.5999999999999999\n 2.1999999999999997\n 2.6\n 3.0000000000000004\n 3.600000000000001\n 4.000000000000001\n 4.600000000000001\n 5.000000000000002\n\nAs shown above example, islogpoint(logger) is true when time t become first greater than or equalt to logpoints.\n\n\n\n\n\n","category":"type"},{"location":"Collections/","page":"Poingr.Collections","title":"Poingr.Collections","text":"CurrentModule = Poingr.Collections","category":"page"},{"location":"Collections/#Poingr.Collections","page":"Poingr.Collections","title":"Poingr.Collections","text":"","category":"section"},{"location":"Collections/","page":"Poingr.Collections","title":"Poingr.Collections","text":"Modules = [Collections]\nOrder = [:type, :function]","category":"page"},{"location":"Collections/","page":"Poingr.Collections","title":"Poingr.Collections","text":"Modules = [Collections]\nOrder = [:type, :function]","category":"page"},{"location":"Collections/#Poingr.Collections.AbstractCollection","page":"Poingr.Collections","title":"Poingr.Collections.AbstractCollection","text":"AbstractCollection{rank}\n\nSupertype for collections.\n\n\n\n\n\n","category":"type"},{"location":"Collections/#Poingr.Collections.Collection","page":"Poingr.Collections","title":"Poingr.Collections.Collection","text":"Collection(x, [Val(rank)])\n\n\n\n\n\n","category":"type"},{"location":"Collections/#Poingr.Collections.LazyOperationType","page":"Poingr.Collections","title":"Poingr.Collections.LazyOperationType","text":"LazyCollections.LazyOperationType(f)\n\nThis needs to be overrided for custom operator. Return LazyAddLikeOperator() or LazyMulLikeOperator().\n\n\n\n\n\n","category":"type"},{"location":"Collections/#Poingr.Collections.return_dims-Tuple{Any, Vararg{Any, N} where N}","page":"Poingr.Collections","title":"Poingr.Collections.return_dims","text":"return_dims(f, args...)\n\nGet returned dimensions.\n\n\n\n\n\n","category":"method"},{"location":"Collections/#Poingr.Collections.return_rank-Tuple{Any, Vararg{Any, N} where N}","page":"Poingr.Collections","title":"Poingr.Collections.return_rank","text":"return_rank(f, args...)\n\nGet returned rank.\n\n\n\n\n\n","category":"method"},{"location":"DofHelpers/","page":"Poingr.DofHelpers","title":"Poingr.DofHelpers","text":"CurrentModule = Poingr.DofHelpers","category":"page"},{"location":"DofHelpers/#Poingr.DofHelpers","page":"Poingr.DofHelpers","title":"Poingr.DofHelpers","text":"","category":"section"},{"location":"DofHelpers/","page":"Poingr.DofHelpers","title":"Poingr.DofHelpers","text":"Modules = [DofHelpers]\nOrder = [:type, :function]","category":"page"},{"location":"DofHelpers/","page":"Poingr.DofHelpers","title":"Poingr.DofHelpers","text":"Modules = [DofHelpers]\nOrder = [:type, :function]","category":"page"},{"location":"DofHelpers/#Poingr.DofHelpers.DofMap","page":"Poingr.DofHelpers","title":"Poingr.DofHelpers.DofMap","text":"DofMap(dims...)\n\nCreate function-like object for dof mapping. DofMap also behave like a bool array to activate/deactivate indices. To finalize activations and perform numbering dofs, use count!(::DofMap).\n\ncount!(::DofMap)\n(DofMap)(index...; [dof])\nDofHelpers.map(::DofMap, inds; [dof])\nDofHelpers.filter(::DofMap, inds)\n\n\n\n\n\n","category":"type"},{"location":"DofHelpers/#Poingr.DofHelpers.DofMap-Tuple","page":"Poingr.DofHelpers","title":"Poingr.DofHelpers.DofMap","text":"(::DofMap)(index...; [dof])\n\nReturn dof from given nodal index. Use DofHelpers.map(::DofMap, indices::AbstractArray) for multiple indices.\n\nExamples\n\njulia> dofmap = DofMap(5, 5)\n5×5 DofMap{2}:\n 0  0  0  0  0\n 0  0  0  0  0\n 0  0  0  0  0\n 0  0  0  0  0\n 0  0  0  0  0\n\njulia> dofmap[1:2, 2:3] .= true; dofmap\n5×5 DofMap{2}:\n 0  1  1  0  0\n 0  1  1  0  0\n 0  0  0  0  0\n 0  0  0  0  0\n 0  0  0  0  0\n\njulia> count!(dofmap)\n4\n\njulia> dofmap(1, 1) === nothing\ntrue\n\njulia> dofmap(2, 2)\n2\n\njulia> dofmap(2, 2, dof = 1)\n2:2\n\njulia> dofmap(2, 2, dof = 2)\n3:4\n\n\n\n\n\n","category":"method"},{"location":"DofHelpers/#Base.count!-Tuple{DofMap}","page":"Poingr.DofHelpers","title":"Base.count!","text":"count!(::DofMap)\n\nCount active indices and numbering dofs. Returned integer is the number of active indices.\n\nExamples\n\njulia> dofmap = DofMap(5, 5)\n5×5 DofMap{2}:\n 0  0  0  0  0\n 0  0  0  0  0\n 0  0  0  0  0\n 0  0  0  0  0\n 0  0  0  0  0\n\njulia> dofmap[1:2, 2:3] .= true; dofmap\n5×5 DofMap{2}:\n 0  1  1  0  0\n 0  1  1  0  0\n 0  0  0  0  0\n 0  0  0  0  0\n 0  0  0  0  0\n\njulia> count!(dofmap)\n4\n\n\n\n\n\n","category":"method"},{"location":"DofHelpers/#Poingr.DofHelpers.filter-Tuple{DofMap, AbstractArray}","page":"Poingr.DofHelpers","title":"Poingr.DofHelpers.filter","text":"DofHelpers.filter(::DofMap, inds::AbstractArray)\nDofHelpers.filter!(::DofMap, output::Vector, inds::AbstractArray)\n\nThis is the same as inds[dofmap[inds]] but more effective.\n\nExamples\n\njulia> dofmap = DofMap(5, 5)\n5×5 DofMap{2}:\n 0  0  0  0  0\n 0  0  0  0  0\n 0  0  0  0  0\n 0  0  0  0  0\n 0  0  0  0  0\n\njulia> dofmap[1:2, 2:3] .= true; dofmap\n5×5 DofMap{2}:\n 0  1  1  0  0\n 0  1  1  0  0\n 0  0  0  0  0\n 0  0  0  0  0\n 0  0  0  0  0\n\njulia> count!(dofmap)\n4\n\njulia> DofHelpers.filter(dofmap, CartesianIndices((1:2, 1:2)))\n2-element Vector{CartesianIndex{2}}:\n CartesianIndex(1, 2)\n CartesianIndex(2, 2)\n\n\n\n\n\n","category":"method"},{"location":"DofHelpers/#Poingr.DofHelpers.map-Tuple{DofMap, AbstractArray}","page":"Poingr.DofHelpers","title":"Poingr.DofHelpers.map","text":"DofHelpers.map(::DofMap, indices::AbstractArray; [dof])\nDofHelpers.map!(::DofMap, dofs::Vector{Int}, indices::AbstractArray; [dof])\n\nMap nodal indices to dof indices. This is almost the same behavior as performing dofmap(index) at each elemnt of indices but nothing is skipped.\n\nExamples\n\njulia> dofmap = DofMap(5, 5)\n5×5 DofMap{2}:\n 0  0  0  0  0\n 0  0  0  0  0\n 0  0  0  0  0\n 0  0  0  0  0\n 0  0  0  0  0\n\njulia> dofmap[1:2, 2:3] .= true; dofmap\n5×5 DofMap{2}:\n 0  1  1  0  0\n 0  1  1  0  0\n 0  0  0  0  0\n 0  0  0  0  0\n 0  0  0  0  0\n\njulia> count!(dofmap)\n4\n\njulia> DofHelpers.map(dofmap, CartesianIndices((1:2, 1:2)); dof = 2)\n4-element Vector{Int64}:\n 1\n 2\n 3\n 4\n\njulia> DofHelpers.map(dofmap, [CartesianIndex(1, 2), CartesianIndex(2, 3)]; dof = 2)\n4-element Vector{Int64}:\n 1\n 2\n 7\n 8\n\n\n\n\n\n","category":"method"},{"location":"DofHelpers/#Poingr.DofHelpers.ndofs-Tuple{DofMap}","page":"Poingr.DofHelpers","title":"Poingr.DofHelpers.ndofs","text":"ndofs(::DofMap; [dof])\n\nReturn total number of dofs.\n\n\n\n\n\n","category":"method"},{"location":"ShapeFunctions/","page":"Poingr.ShapeFunctions","title":"Poingr.ShapeFunctions","text":"CurrentModule = Poingr.ShapeFunctions","category":"page"},{"location":"ShapeFunctions/#Poingr.ShapeFunctions","page":"Poingr.ShapeFunctions","title":"Poingr.ShapeFunctions","text":"","category":"section"},{"location":"ShapeFunctions/","page":"Poingr.ShapeFunctions","title":"Poingr.ShapeFunctions","text":"Modules = [ShapeFunctions]\nOrder = [:type, :function]","category":"page"},{"location":"ShapeFunctions/","page":"Poingr.ShapeFunctions","title":"Poingr.ShapeFunctions","text":"Modules = [ShapeFunctions]\nOrder = [:type, :function]","category":"page"},{"location":"ShapeFunctions/#Poingr.ShapeFunctions.BSpline","page":"Poingr.ShapeFunctions","title":"Poingr.ShapeFunctions.BSpline","text":"BSpline{order}(dim)\nBSpline{order}(; dim)\n\nCreate B-spline shape function.\n\nExamples\n\njulia> f = BSpline{1}(dim = 2)\nBSpline{1}(dim = 2)\n\njulia> f(Vec(0.5, 0.5))\n0.25\n\n\n\n\n\n","category":"type"},{"location":"ShapeFunctions/#Poingr.ShapeFunctions.BSplinePosition","page":"Poingr.ShapeFunctions","title":"Poingr.ShapeFunctions.BSplinePosition","text":"BSplinePosition(; nth::Int, dir::Int)\n\nPosition of node at ξ = 0. The node is located at nth away from bound with dir direction.\n\nExamples\n\njulia> BSplinePosition([1,2,3,4,5], 2)\nBSplinePosition(nth = 1, dir = 1)\n\njulia> BSplinePosition([1,2,3,4,5], 4)\nBSplinePosition(nth = 1, dir = -1)\n\njulia> pos = BSplinePosition([1,2,3,4,5], 1)\nBSplinePosition(nth = 0, dir = 0)\n\njulia> f = BSpline{2}(dim = 0)\nBSpline{2}(dim = 0)\n\njulia> f(0.0, pos)\n1.0\n\n\n\n\n\n","category":"type"},{"location":"ShapeFunctions/#Poingr.ShapeFunctions.construct-Union{Tuple{ShapeFunction{dim}}, Tuple{dim}} where dim","page":"Poingr.ShapeFunctions","title":"Poingr.ShapeFunctions.construct","text":"construct(::ShapeFunction)\nconstruct(::Type{T}, ::ShapeFunction)\n\nConstruct object storing value of ShapeFunction.\n\nExamples\n\njulia> N = construct(QuadraticBSpline(dim = 2));\n\njulia> reinit!(N, Grid(0:3, 0:3), Vec(1, 1));\n\njulia> sum(N)\n1.0\n\njulia> sum(∇, N)\n2-element Vec{2, Float64}:\n 5.551115123125783e-17\n 5.551115123125783e-17\n\n\n\n\n\n","category":"method"},{"location":"ShapeFunctions/#Poingr.ShapeFunctions.reinit!","page":"Poingr.ShapeFunctions","title":"Poingr.ShapeFunctions.reinit!","text":"reinit!(::ShapeValue, grid::AbstractGrid, x::Vec)\nreinit!(::ShapeValue, grid::AbstractGrid, indices::AbstractArray, x::Vec)\n\nReinitialize value of shape function at x with each grid node.\n\nExamples\n\njulia> N = construct(QuadraticBSpline(dim = 2));\n\njulia> reinit!(N, Grid(0:3, 0:3), Vec(1, 1));\n\njulia> sum(N)\n1.0\n\njulia> reinit!(N, Grid(0:3, 0:3), CartesianIndices((1:2, 1:2)), Vec(1, 1));\n\njulia> sum(N)\n0.765625\n\n\n\n\n\n","category":"function"},{"location":"Arrays/","page":"Poingr.Arrays","title":"Poingr.Arrays","text":"CurrentModule = Poingr.Arrays","category":"page"},{"location":"Arrays/#Poingr.Arrays","page":"Poingr.Arrays","title":"Poingr.Arrays","text":"","category":"section"},{"location":"Arrays/","page":"Poingr.Arrays","title":"Poingr.Arrays","text":"Modules = [Arrays]\nOrder = [:type, :function]","category":"page"},{"location":"Arrays/","page":"Poingr.Arrays","title":"Poingr.Arrays","text":"Modules = [Arrays]\nOrder = [:type, :function]","category":"page"},{"location":"Arrays/#Poingr.Arrays.SparseMatrixCOO","page":"Poingr.Arrays","title":"Poingr.Arrays.SparseMatrixCOO","text":"SparseMatrixCOO([N = 0])\n\nConstruct sparse matrix using COOrdinate format.\n\nExamples\n\njulia> S = SparseMatrixCOO();\n\njulia> push!(S, [1.0 1.0; 1.0 1.0], [1, 2], [2, 3]);\n\njulia> sparse!(S, 4, 4)\n4×4 SparseMatrixCSC{Float64, Int64} with 4 stored entries:\n  ⋅   1.0  1.0   ⋅\n  ⋅   1.0  1.0   ⋅\n  ⋅    ⋅    ⋅    ⋅\n  ⋅    ⋅    ⋅    ⋅\n\njulia> push!(S, [1.0, 2.0], [1, 2]); # Add diagonal entries\n\njulia> sparse!(S)\n2×3 SparseMatrixCSC{Float64, Int64} with 5 stored entries:\n 1.0  1.0  1.0\n  ⋅   3.0  1.0\n\n\n\n\n\n","category":"type"},{"location":"MPSpaces/","page":"Poingr.MPSpaces","title":"Poingr.MPSpaces","text":"CurrentModule = Poingr.MPSpaces","category":"page"},{"location":"MPSpaces/#Poingr.MPSpaces","page":"Poingr.MPSpaces","title":"Poingr.MPSpaces","text":"","category":"section"},{"location":"MPSpaces/","page":"Poingr.MPSpaces","title":"Poingr.MPSpaces","text":"Modules = [MPSpaces]\nOrder = [:type, :function]","category":"page"},{"location":"MPSpaces/","page":"Poingr.MPSpaces","title":"Poingr.MPSpaces","text":"Modules = [MPSpaces]\nOrder = [:type, :function]","category":"page"},{"location":"MPSpaces/#Poingr.DofHelpers.ndofs-Tuple{MPSpace}","page":"Poingr.MPSpaces","title":"Poingr.DofHelpers.ndofs","text":"ndofs(::MPSpace; [dof])\n\nReturn total number of dofs.\n\n\n\n\n\n","category":"method"},{"location":"MPSpaces/#Poingr.MPSpaces.dofindices-Union{Tuple{dim}, Tuple{MPSpace{dim, FT, GT, VT} where {FT<:ShapeFunction{dim}, GT<:(AbstractGrid{dim, T} where T), VT<:(ShapeValue{dim, T} where T)}, Int64}} where dim","page":"Poingr.MPSpaces","title":"Poingr.MPSpaces.dofindices","text":"dofindices(::MPSpace, p::Int; [dof])\n\nReturn dof indices at point index p. Use reinit!(::MPSpace, ::AbstractArray{<: Vec}) in advance.\n\n\n\n\n\n","category":"method"},{"location":"MPSpaces/#Poingr.MPSpaces.gridindices-Tuple{MPSpace, Int64}","page":"Poingr.MPSpaces","title":"Poingr.MPSpaces.gridindices","text":"gridindices(::MPSpace, p::Int)\n\nReturn grid indices at point index p. Use reinit!(::MPSpace, ::AbstractArray{<: Vec}) in advance.\n\n\n\n\n\n","category":"method"},{"location":"#Poingr","page":"Home","title":"Poingr","text":"","category":"section"},{"location":"VTKOutputs/","page":"Poingr.VTKOutputs","title":"Poingr.VTKOutputs","text":"CurrentModule = Poingr.VTKOutputs","category":"page"},{"location":"VTKOutputs/#Poingr.VTKOutputs","page":"Poingr.VTKOutputs","title":"Poingr.VTKOutputs","text":"","category":"section"},{"location":"VTKOutputs/","page":"Poingr.VTKOutputs","title":"Poingr.VTKOutputs","text":"Modules = [VTKOutputs]\nOrder = [:type, :function]","category":"page"},{"location":"VTKOutputs/","page":"Poingr.VTKOutputs","title":"Poingr.VTKOutputs","text":"Modules = [VTKOutputs]\nOrder = [:type, :function]","category":"page"},{"location":"VTKOutputs/#Poingr.VTKOutputs.vtk_points-Tuple{Any, Union{PointState{var\"#s230\"} where var\"#s230\"<:(Vec{dim, T} where {dim, T}), AbstractVector{var\"#s227\"} where var\"#s227\"<:(Vec{dim, T} where {dim, T})}}","page":"Poingr.VTKOutputs","title":"Poingr.VTKOutputs.vtk_points","text":"vtk_points(filename::AbstractString, points::PointState{<: Vec})\n\nCreate VTK file to visualize points. This should be used instead of calling vtk_grid in WriteVTK package.\n\nExamples\n\njulia> grid = Grid(0.0:1.0:10.0, 0.0:1.0:10.0);\n\njulia> xₚ, = generate_pointstates((x, y) -> (x-5)^2 + (y-5)^2 < 3^2, grid, n = 4);\n\njulia> vtkfile = vtk_points(\"vtkfile\", xₚ)\nVTK file 'vtkfile.vtu' (UnstructuredGrid file, open)\n\njulia> vtk_save(vtkfile)\n1-element Vector{String}:\n \"vtkfile.vtu\"\n\n\n\n\n\n","category":"method"},{"location":"VTKOutputs/#WriteVTK.vtk_grid-Tuple{AbstractString, AbstractGrid}","page":"Poingr.VTKOutputs","title":"WriteVTK.vtk_grid","text":"vtk_grid(filename::AbstractString, grid::Grid)\n\nCreate a structured VTK grid from a Grid.\n\nExamples\n\njulia> grid = Grid(0.0:1.0:10.0, 0.0:1.0:10.0);\n\njulia> vtkfile = vtk_grid(\"vtkfile\", grid)\nVTK file 'vtkfile.vtr' (RectilinearGrid file, open)\n\njulia> vtk_save(vtkfile)\n1-element Vector{String}:\n \"vtkfile.vtr\"\n\n\n\n\n\n","category":"method"},{"location":"VTKOutputs/#WriteVTK.vtk_point_data-Tuple{WriteVTK.DatasetFile, Union{PointState{var\"#s230\"} where var\"#s230\"<:Tensor, AbstractVector{var\"#s227\"} where var\"#s227\"<:Tensor}, AbstractString}","page":"Poingr.VTKOutputs","title":"WriteVTK.vtk_point_data","text":"vtk_point_data(vtk, data::AbstractVector{ <:Vec}, name)\n\nWrite the vector field data to the vtk file.\n\n\n\n\n\n","category":"method"}]
}
