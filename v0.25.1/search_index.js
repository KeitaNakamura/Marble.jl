var documenterSearchIndex = {"docs":
[{"location":"contact_mechanics/","page":"Contact mechanics","title":"Contact mechanics","text":"DocTestSetup = :(using Marble)","category":"page"},{"location":"contact_mechanics/#Contact-mechanics","page":"Contact mechanics","title":"Contact mechanics","text":"","category":"section"},{"location":"contact_mechanics/","page":"Contact mechanics","title":"Contact mechanics","text":"Order = [:type, :function]\nPages = [\"contact_mechanics.md\"]","category":"page"},{"location":"contact_mechanics/","page":"Contact mechanics","title":"Contact mechanics","text":"Modules = [Marble]\nOrder   = [:type, :function]\nPages   = [\"contact.jl\"]","category":"page"},{"location":"contact_mechanics/#Marble.CoulombFriction-Tuple{Symbol}","page":"Contact mechanics","title":"Marble.CoulombFriction","text":"CoulombFriction(:sticky)\n\nThis is the same as the CoulombFriction(; μ = Inf).\n\n\n\nCoulombFriction(:slip; separation = false)\n\nThis is the same as the CoulombFriction(; μ = 0, separation = false).\n\n\n\nCoulombFriction(:free)\n\nNo boundary condition. This is the same as the CoulombFriction(; μ = NaN).\n\n\n\n\n\n","category":"method"},{"location":"contact_mechanics/#Marble.CoulombFriction-Tuple{}","page":"Contact mechanics","title":"Marble.CoulombFriction","text":"CoulombFriction(; parameters...)\n\nFrictional contact using Mohr-Coulomb criterion.\n\nParameters\n\nμ: friction coefficient (use μ or ϕ)\nϕ: friction angle (radian)\nc: cohesion (default: 0)\nseparation: true or false (default: false).\n\nIf separation is true, continuum body can leave from the boundary surface.\n\n\n\n\n\n","category":"method"},{"location":"contact_mechanics/#Marble.contacted-Union{Tuple{T}, Tuple{dim}, Tuple{CoulombFriction, Vec{dim, T}, Vec{dim, T}}} where {dim, T}","page":"Contact mechanics","title":"Marble.contacted","text":"contacted(::CoulombFriction, q::Vec, n::Vec)\n\nCompute q caused by contact. q can be used as velocity (relative velocity) v or force f. n is the unit vector normal to the surface.\n\nExamples\n\njulia> cond = CoulombFriction(:slip, separation = false);\n\njulia> v = Vec(1.0, -1.0); n = Vec(0.0, 1.0);\n\njulia> v + contacted(cond, v, n)\n2-element Vec{2, Float64}:\n 1.0\n 0.0\n\njulia> v + contacted(CoulombFriction(:free), v, n) == v\ntrue\n\n\n\n\n\n","category":"method"},{"location":"interpolations/","page":"Interpolations","title":"Interpolations","text":"DocTestSetup = :(using Marble)","category":"page"},{"location":"interpolations/#Interpolations","page":"Interpolations","title":"Interpolations","text":"","category":"section"},{"location":"interpolations/","page":"Interpolations","title":"Interpolations","text":"Order = [:type, :function]\nPages = [\"interpolations.md\"]","category":"page"},{"location":"interpolations/","page":"Interpolations","title":"Interpolations","text":"Modules = [Marble]\nOrder   = [:type, :function]\nPages   = [\"Interpolations/mpvalues.jl\",\n           \"Interpolations/bspline.jl\",\n           \"Interpolations/wls.jl\"]","category":"page"},{"location":"interpolations/#Marble.MPValues-Union{Tuple{Interpolation}, Tuple{dim}} where dim","page":"Interpolations","title":"Marble.MPValues","text":"MPValues{dim}(::Interpolation)\nMPValues{dim, T}(::Interpolation)\n\nConstruct object storing value of Interpolation.\n\nExamples\n\njulia> mpvalues = MPValues{2}(QuadraticBSpline());\n\njulia> update!(mpvalues, Grid(0.0:3.0, 0.0:3.0), Vec(1, 1));\n\njulia> sum(mpvalues.N)\n1.0\n\njulia> sum(mpvalues.∇N)\n2-element Vec{2, Float64}:\n 5.551115123125783e-17\n 5.551115123125783e-17\n\n\n\n\n\n","category":"method"},{"location":"interpolations/#Marble.BSpline","page":"Interpolations","title":"Marble.BSpline","text":"BSpline{order}()\nLinearBSpline()\nQuadraticBSpline()\nCubicBSpline()\n\nCreate B-spline kernel.\n\nExamples\n\njulia> f = LinearBSpline()\nLinearBSpline()\n\njulia> Marble.value(f, Vec(0.5, 0.5))\n0.25\n\n\n\n\n\n","category":"type"},{"location":"VTK_outputs/","page":"VTK outputs","title":"VTK outputs","text":"DocTestSetup = :(using Marble)","category":"page"},{"location":"VTK_outputs/#Marble.VTKOutputs","page":"VTK outputs","title":"Marble.VTKOutputs","text":"","category":"section"},{"location":"VTK_outputs/","page":"VTK outputs","title":"VTK outputs","text":"Order = [:type, :function]\nPages = [\"VTK_outputs.md\"]","category":"page"},{"location":"VTK_outputs/","page":"VTK outputs","title":"VTK outputs","text":"Modules = [Marble]\nOrder   = [:type, :function]\nPages   = [\"vtk.jl\"]","category":"page"},{"location":"VTK_outputs/#Marble.vtk_points-Tuple{Any, AbstractVector{<:Vec}}","page":"VTK outputs","title":"Marble.vtk_points","text":"vtk_points(filename::AbstractString, points::AbstractVector{<: Vec})\n\nCreate VTK file to visualize points. This should be used instead of calling vtk_grid in WriteVTK package.\n\nExamples\n\njulia> grid = Grid(0.0:1.0:10.0, 0.0:1.0:10.0);\n\njulia> pointstate = generate_pointstate((x, y) -> (x-5)^2 + (y-5)^2 < 3^2, grid, n = 4);\n\njulia> vtkfile = vtk_points(\"vtkfile\", pointstate.x)\nVTK file 'vtkfile.vtu' (UnstructuredGrid file, open)\n\njulia> vtk_save(vtkfile)\n1-element Vector{String}:\n \"vtkfile.vtu\"\n\n\n\n\n\n","category":"method"},{"location":"VTK_outputs/#WriteVTK.vtk_grid-Tuple{AbstractString, Grid}","page":"VTK outputs","title":"WriteVTK.vtk_grid","text":"vtk_grid(filename::AbstractString, grid::Grid)\n\nCreate a structured VTK grid from a Grid.\n\nExamples\n\njulia> grid = Grid(0.0:1.0:10.0, 0.0:1.0:10.0);\n\njulia> vtkfile = vtk_grid(\"vtkfile\", grid)\nVTK file 'vtkfile.vtr' (RectilinearGrid file, open)\n\njulia> vtk_save(vtkfile)\n1-element Vector{String}:\n \"vtkfile.vtr\"\n\n\n\n\n\n","category":"method"},{"location":"grid/","page":"Grid","title":"Grid","text":"DocTestSetup = :(using Marble)","category":"page"},{"location":"grid/#Grid","page":"Grid","title":"Grid","text":"","category":"section"},{"location":"grid/","page":"Grid","title":"Grid","text":"Order = [:type, :function]\nPages = [\"grid.md\"]","category":"page"},{"location":"grid/","page":"Grid","title":"Grid","text":"Modules = [Marble]\nOrder   = [:type, :function]\nPages   = [\"grid.jl\"]","category":"page"},{"location":"grid/#Marble.Grid","page":"Grid","title":"Marble.Grid","text":"Grid([::Type{NodeState}], [::Interpolation], axes::AbstractVector...)\n\nConstruct Grid by axes.\n\nExamples\n\njulia> Grid(range(0, 3, step = 1.0), range(1, 4, step = 1.0))\n4×4 Grid{Float64, 2, Nothing, Nothing, Marble.SpArray{Nothing, 2, StructArrays.StructVector{Nothing, NamedTuple{(), Tuple{}}, Int64}}, PlaneStrain}:\n [0.0, 1.0]  [0.0, 2.0]  [0.0, 3.0]  [0.0, 4.0]\n [1.0, 1.0]  [1.0, 2.0]  [1.0, 3.0]  [1.0, 4.0]\n [2.0, 1.0]  [2.0, 2.0]  [2.0, 3.0]  [2.0, 4.0]\n [3.0, 1.0]  [3.0, 2.0]  [3.0, 3.0]  [3.0, 4.0]\n\n\n\n\n\n","category":"type"},{"location":"grid/#Marble.neighbornodes-Union{Tuple{dim}, Tuple{Grid{var\"#s3\", dim, F, Node, State} where {var\"#s3\", F<:Union{Nothing, Interpolation}, Node, State<:(Marble.SpArray{Node, dim, V} where V<:AbstractVector{Node})}, Vec{dim}, Any}} where dim","page":"Grid","title":"Marble.neighbornodes","text":"Marble.neighbornodes(grid, x::Vec, h)\n\nReturn CartesianIndices storing neighboring node indices around x. h is a range for searching and its unit is gridsteps dx. In 1D, for example, the searching range becomes x ± h*dx.\n\nExamples\n\njulia> grid = Grid(0.0:1.0:5.0)\n6-element Grid{Float64, 1, Nothing, Nothing, Marble.SpArray{Nothing, 1, StructArrays.StructVector{Nothing, NamedTuple{(), Tuple{}}, Int64}}, Marble.OneDimensional}:\n [0.0]\n [1.0]\n [2.0]\n [3.0]\n [4.0]\n [5.0]\n\njulia> Marble.neighbornodes(grid, Vec(1.5), 1)\n2-element CartesianIndices{1, Tuple{UnitRange{Int64}}}:\n CartesianIndex(2,)\n CartesianIndex(3,)\n\njulia> Marble.neighbornodes(grid, Vec(1.5), 2)\n4-element CartesianIndices{1, Tuple{UnitRange{Int64}}}:\n CartesianIndex(1,)\n CartesianIndex(2,)\n CartesianIndex(3,)\n CartesianIndex(4,)\n\n\n\n\n\n","category":"method"},{"location":"grid/#Marble.whichblock-Tuple{Grid, Vec}","page":"Grid","title":"Marble.whichblock","text":"Marble.whichblock(grid, x::Vec)\n\nReturn block index where x locates. The unit block size is 2^3 cells.\n\nExamples\n\njulia> grid = Grid(0.0:1.0:10.0, 0.0:1.0:10.0)\n11×11 Grid{Float64, 2, Nothing, Nothing, Marble.SpArray{Nothing, 2, StructArrays.StructVector{Nothing, NamedTuple{(), Tuple{}}, Int64}}, PlaneStrain}:\n [0.0, 0.0]   [0.0, 1.0]   [0.0, 2.0]   …  [0.0, 9.0]   [0.0, 10.0]\n [1.0, 0.0]   [1.0, 1.0]   [1.0, 2.0]      [1.0, 9.0]   [1.0, 10.0]\n [2.0, 0.0]   [2.0, 1.0]   [2.0, 2.0]      [2.0, 9.0]   [2.0, 10.0]\n [3.0, 0.0]   [3.0, 1.0]   [3.0, 2.0]      [3.0, 9.0]   [3.0, 10.0]\n [4.0, 0.0]   [4.0, 1.0]   [4.0, 2.0]      [4.0, 9.0]   [4.0, 10.0]\n [5.0, 0.0]   [5.0, 1.0]   [5.0, 2.0]   …  [5.0, 9.0]   [5.0, 10.0]\n [6.0, 0.0]   [6.0, 1.0]   [6.0, 2.0]      [6.0, 9.0]   [6.0, 10.0]\n [7.0, 0.0]   [7.0, 1.0]   [7.0, 2.0]      [7.0, 9.0]   [7.0, 10.0]\n [8.0, 0.0]   [8.0, 1.0]   [8.0, 2.0]      [8.0, 9.0]   [8.0, 10.0]\n [9.0, 0.0]   [9.0, 1.0]   [9.0, 2.0]      [9.0, 9.0]   [9.0, 10.0]\n [10.0, 0.0]  [10.0, 1.0]  [10.0, 2.0]  …  [10.0, 9.0]  [10.0, 10.0]\n\njulia> Marble.whichblock(grid, Vec(8.5, 1.5))\nCartesianIndex(2, 1)\n\n\n\n\n\n","category":"method"},{"location":"grid/#Marble.whichcell-Union{Tuple{dim}, Tuple{Grid{var\"#s3\", dim, F, Node, State} where {var\"#s3\", F<:Union{Nothing, Interpolation}, Node, State<:(Marble.SpArray{Node, dim, V} where V<:AbstractVector{Node})}, Vec{dim}}} where dim","page":"Grid","title":"Marble.whichcell","text":"Marble.whichcell(grid, x::Vec)\n\nReturn cell index where x locates.\n\nExamples\n\njulia> grid = Grid(0.0:1.0:5.0, 0.0:1.0:5.0)\n6×6 Grid{Float64, 2, Nothing, Nothing, Marble.SpArray{Nothing, 2, StructArrays.StructVector{Nothing, NamedTuple{(), Tuple{}}, Int64}}, PlaneStrain}:\n [0.0, 0.0]  [0.0, 1.0]  [0.0, 2.0]  [0.0, 3.0]  [0.0, 4.0]  [0.0, 5.0]\n [1.0, 0.0]  [1.0, 1.0]  [1.0, 2.0]  [1.0, 3.0]  [1.0, 4.0]  [1.0, 5.0]\n [2.0, 0.0]  [2.0, 1.0]  [2.0, 2.0]  [2.0, 3.0]  [2.0, 4.0]  [2.0, 5.0]\n [3.0, 0.0]  [3.0, 1.0]  [3.0, 2.0]  [3.0, 3.0]  [3.0, 4.0]  [3.0, 5.0]\n [4.0, 0.0]  [4.0, 1.0]  [4.0, 2.0]  [4.0, 3.0]  [4.0, 4.0]  [4.0, 5.0]\n [5.0, 0.0]  [5.0, 1.0]  [5.0, 2.0]  [5.0, 3.0]  [5.0, 4.0]  [5.0, 5.0]\n\njulia> Marble.whichcell(grid, Vec(1.5, 1.5))\nCartesianIndex(2, 2)\n\n\n\n\n\n","category":"method"},{"location":"#Marble","page":"Home","title":"Marble","text":"","category":"section"}]
}
